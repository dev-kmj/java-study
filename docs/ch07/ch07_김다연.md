# 📌 인터페이스 & 내부클래스
## 🏷 인터페이스
### 자바는 다중 상속을 쓸 수 없다. 다중 상속에는 '죽음의 다이아몬드'라고 알려진 문제가 있기 때문임
**다중 상속(multiple inheritance)** : 상위 클래스를 두 개 사용함

### 🖼 죽음의 다이아몬드
![images_chaean_7714_post_c2e39f8e-6770-4203-9166-f8839cc9e35a_image](https://github.com/for-backend-study/java-study/assets/114294615/806ad8c4-7f16-4d77-8566-077fcf95d466)

자바는 죽음의 다이아몬드에 대해서는 신경을 쓰지 않아도 되지만 **다중 상속**이 불가능함!

그럼 이 문제는 어떻게 처리해야 할까?
### 우리에게는 인터페이스가 있다
자바의 인터페이스는 죽음의 다이아몬드(줄여서 DDD) 때문에 생기는 부작용 없이 다중 상속의 다형적인 장점을 대부분 누릴 수 있게 해 줌으로써 **다중 상속 문제를 해결**해 줌

### 인터페이스를 사용해서 DDD 문제를 비켜가는 방법
**모든 메서드를 추상 메서드로 만들자.** 그러면 하위 클래스에서 **반드시** 메서드를 구현해야 하므로 실행 중에 JVM에서 상속받은 두 가지 버전 중에 어떤 것을 호출해야 할지 결정하지 못하는 문제가 생기지 않는다.

|Pet|
|---|
| |
|abstract void beFriendly();|
|abstract void play();|

자바 인터페이스는 100% 순수한 **추상 클래스**와 비슷.

인터페이스에 들어 있는 모든 메서드는 **추상 메서드**이다.

- 인터페이스를 **정의**하려면
  ```java
  public interface Pet {...}
  ```

- 인터페이스를 **구현**하려면
  ```java
  public class Dog extends Canine implements Pet {...}
  ```

### Pet 인터페이스 제작과 구현
```java
public interface Pet {
  public abstract void beFriendly();  // 인터페이스에 들어 있는 메서드는 추상 메서드이므로 반드시 세미콜론으로 끝나야 함
  public abstract void play();
}
```
인터페이스 메서드는 자동으로 `public`, `abstract`가 되므로 `public`, `abstract`는 쓰지 않아도 된다!!

```java
public class Dog extends Canine implements Pet {
  public void beFriendly() {...}   // Pet의 메서드를 반드시 구현해야 함
  public void play() {...}

  public void roam() {...}
  public void eat() {...}
}
```

### 🖼 서로 다른 상속 트리에 속한 클래스에서도 같은 인터페이스를 구현할 수 있다.
![images_chaean_7714_post_46d5aa66-e5e0-4c58-9a1c-1858c537116b_image](https://github.com/for-backend-study/java-study/assets/114294615/226037e5-fe13-4a0e-9344-1b0240356b88)

- 어떤 클래스를 다형적인 타입으로 사용하면 **같은 상속 트리**에 속한 타입만 집어넣을 수 있다.
- 인자 타입을 `Canine`으로 지정하면 `Wolf`나 `Dog` 객체는 받아들일 수 있지만, `Cat`이나 `Hippo`는 받아들일 수 없다. (사진 참고)
- 하지만 **인터페이스**를 다형적인 타입으로 사용하면 어떤 상속 트리에 있는 객체도 집어넣을 수 있다.
- 한 클래스에서 **인터페이스 여러 개**를 구현할 수도 있다.
  ```java
  public class Dog extends Animal implements Pet, Saveable, Paintable {...}
  ```

### 하위 클래스? 추상 클래스? 인터페이스?
- 클래스를 새로 만들 때 그 클래스가 다른 어떤 타입에 대해서도 'A는 B다' 테스트를 통과할 수 없다면 --> **그냥 클래스**
- 어떤 클래스의 더 구체적인 버전을 만들고 어떤 메서드를 오버라이드하거나 새로운 행동을 추가해야 한다면 --> **하위 클래스**
- 하위 클래스에서 사용할 틀을 정의하고 싶다면, 그리고 모든 하위 클래스에서 사용할 구현 코드가 조금이라도 있다면 --> **추상 클래스**
- 상속 트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면 --> **인터페이스**

### 상위 클래스에 있는 버전의 메서드를 호출하는 방법
```java
abstract class Report { 
  void runReport() {      // 상위 클래스 버전의 메서드에서 하위 클래스에 사용할 수 있는 중요한 작업을 처리함
    // 코드
  }
  void printReport() {
    // 코드
  }
}
```

```java
class BuzzwordsReport extends Report {
  void runReport() {
    super.runReport();    // 상위 클래스 버전을 호출한 다음 하위 클래스에서 해야할 일을 처리함
    buzzwordCompliance();
    printReport();
  }

  void buzzwordCompliance() {...}
}
```
`super.runReport();`로 호출하면 `Report` 상위 클래스에 있는 `runReport()` 메서드가 실행됨
