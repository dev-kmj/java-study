# 📌 인터페이스 & 내부클래스
## 🏷 인터페이스
### 자바는 다중 상속을 쓸 수 없다. 다중 상속에는 '죽음의 다이아몬드'라고 알려진 문제가 있기 때문임
**다중 상속(multiple inheritance)** : 상위 클래스를 두 개 사용함

### 🖼 죽음의 다이아몬드
![images_chaean_7714_post_c2e39f8e-6770-4203-9166-f8839cc9e35a_image](https://github.com/for-backend-study/java-study/assets/114294615/806ad8c4-7f16-4d77-8566-077fcf95d466)

자바는 죽음의 다이아몬드에 대해서는 신경을 쓰지 않아도 되지만 **다중 상속**이 불가능함!

그럼 이 문제는 어떻게 처리해야 할까?
### 우리에게는 인터페이스가 있다
자바의 인터페이스는 죽음의 다이아몬드(줄여서 DDD) 때문에 생기는 부작용 없이 다중 상속의 다형적인 장점을 대부분 누릴 수 있게 해 줌으로써 **다중 상속 문제를 해결**해 줌

### 인터페이스를 사용해서 DDD 문제를 비켜가는 방법
**모든 메서드를 추상 메서드로 만들자.** 그러면 하위 클래스에서 **반드시** 메서드를 구현해야 하므로 실행 중에 JVM에서 상속받은 두 가지 버전 중에 어떤 것을 호출해야 할지 결정하지 못하는 문제가 생기지 않는다.

|Pet|
|---|
| |
|abstract void beFriendly();|
|abstract void play();|

자바 인터페이스는 100% 순수한 **추상 클래스**와 비슷.

인터페이스에 들어 있는 모든 메서드는 **추상 메서드**이다.

- 인터페이스를 **정의**하려면
  ```java
  public interface Pet {...}
  ```

- 인터페이스를 **구현**하려면
  ```java
  public class Dog extends Canine implements Pet {...}
  ```

### Pet 인터페이스 제작과 구현
```java
public interface Pet {
  public abstract void beFriendly();  // 인터페이스에 들어 있는 메서드는 추상 메서드이므로 반드시 세미콜론으로 끝나야 함
  public abstract void play();
}
```
인터페이스 메서드는 자동으로 `public`, `abstract`가 되므로 `public`, `abstract`는 쓰지 않아도 된다!!

```java
public class Dog extends Canine implements Pet {
  public void beFriendly() {...}   // Pet의 메서드를 반드시 구현해야 함
  public void play() {...}

  public void roam() {...}
  public void eat() {...}
}
```

### 🖼 서로 다른 상속 트리에 속한 클래스에서도 같은 인터페이스를 구현할 수 있다.
![images_chaean_7714_post_46d5aa66-e5e0-4c58-9a1c-1858c537116b_image](https://github.com/for-backend-study/java-study/assets/114294615/226037e5-fe13-4a0e-9344-1b0240356b88)

- 어떤 클래스를 다형적인 타입으로 사용하면 **같은 상속 트리**에 속한 타입만 집어넣을 수 있다.
- 인자 타입을 `Canine`으로 지정하면 `Wolf`나 `Dog` 객체는 받아들일 수 있지만, `Cat`이나 `Hippo`는 받아들일 수 없다. (사진 참고)
- 하지만 **인터페이스**를 다형적인 타입으로 사용하면 어떤 상속 트리에 있는 객체도 집어넣을 수 있다.
- 한 클래스에서 **인터페이스 여러 개**를 구현할 수도 있다.
  ```java
  public class Dog extends Animal implements Pet, Saveable, Paintable {...}
  ```

### 하위 클래스? 추상 클래스? 인터페이스?
- 클래스를 새로 만들 때 그 클래스가 다른 어떤 타입에 대해서도 'A는 B다' 테스트를 통과할 수 없다면 --> **그냥 클래스**
- 어떤 클래스의 더 구체적인 버전을 만들고 어떤 메서드를 오버라이드하거나 새로운 행동을 추가해야 한다면 --> **하위 클래스**
- 하위 클래스에서 사용할 틀을 정의하고 싶다면, 그리고 모든 하위 클래스에서 사용할 구현 코드가 조금이라도 있다면 --> **추상 클래스**
- 상속 트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면 --> **인터페이스**

### 상위 클래스에 있는 버전의 메서드를 호출하는 방법
```java
abstract class Report { 
  void runReport() {      // 상위 클래스 버전의 메서드에서 하위 클래스에 사용할 수 있는 중요한 작업을 처리함
    // 코드
  }
  void printReport() {
    // 코드
  }
}
```

```java
class BuzzwordsReport extends Report {
  void runReport() {
    super.runReport();    // 상위 클래스 버전을 호출한 다음 하위 클래스에서 해야할 일을 처리함
    buzzwordCompliance();
    printReport();
  }

  void buzzwordCompliance() {...}
}
```
`super.runReport();`로 호출하면 `Report` 상위 클래스에 있는 `runReport()` 메서드가 실행됨

## 🏷 내부 클래스
Java에서 내부 클래스는 하나의 클래스 또는 인터페이스 내부에 선언된 클래스를 의미함

### 내부 클래스 종류
- **인스턴스 내부 클래스 (Instance Inner class)** : 외부 클래스의 인스턴스와 밀접하게 관련된 내부 클래스. 인스턴스 내부 클래스는 주로 외부 클래스의 인스턴스와 데이터를 공유하고, 객체 간의 관계를 모델링하는데 사용됨.
- **정적 내부 클래스 (Static Inner Class)** : 정적 내부 클래스는 외부 클래스의 인스턴스와 독립적으로 정적으로 정의된 내부 클래스. 외부 클래스의 인스턴스를 생성하지 않고도 사용할 수 있음.
- **지역 내부 클래스 (Local Inner Class)** : 지역 내부 클래스는 메서드 내에서 정의되며, 해당 메서드의 변수에 접근할 수 있는 내부 클래스. 주로 특정 메서드에서만 사용되는 클래스를 정의할 때 활용됨.
- **익명 내부 클래스 (Anonymous Inner Class)** : 익명 내부 클래스는 이름 없이 정의되며, 클래스 정의와 객체 생성이 결합된 내부 클래스. 인터페이스의 익명 구현체를 생성하거나 간단한 이벤트 핸들러를 구현할 때 주로 사용됨.

### 내부 클래스 장점
- **캡슐화와 모듈화** : 내부 클래스를 사용하면 관련된 클래스 및 코드를 논리적으로 그룹화하여 캡슐화와 모듈화를 촉진한다. 관련 기능을 하나의 단위로 묶어 코드의 가독성을 향상시킨다.
- **코드 재사용성** : 내부 클래스를 사용하면 외부 클래스와 함께 사용될 때 유용한 중첩된 클래스를 정의할 수 있으므로 코드의 재사용성을 높일 수 있다.
- **외부 클래스와의 강한 연관성** : 인스턴스 내부 클래스와 외부 클래스의 인스턴스 간에 강한 연관성이 있어, 내부 클래스가 외부 클래스의 데이터와 동작에 쉽게 접근할 수 있다.
- **은닉화 및 데이터 보호** : 내부 클래스는 외부에서의 직접적인 접근을 제한할 수 있으며, private 멤버에 대한 접근을 허용하면서도 데이터 은닉을 유지할 수 있다.
- **객체 지향 설계** : 내부 클래스는 객체 지향 설계 원칙 중 응집성(cohesion)을 높이고 결합도(coupling)를 낮추는 데 도움이 됨. 클래스 간의 관계를 더 명확하게 정의할 수 있다.

### 내부 클래스 단점
- **복잡성 증가** : 내부 클래스를 남용하면 코드가 복잡해질 수 있다. 적절한 상황에서만 내부 클래스를 사용해야 하며, 과도한 중첩 클래스 정의는 코드를 어렵게 만들 수 있다.
- **메모리 사용** : 내부 클래스는 외부 클래스의 인스턴스와 연결되므로 많은 인스턴스 내부 클래스 객체를 생성하면 메모리 사용량이 증가할 수 있다.
- **가독성 감소** : 과도한 중첩 클래스 사용은 코드의 가독성을 저하시킬 수 있다. 특히 복잡한 중첩 구조를 가진 경우 코드 이해가 어려워질 수 있다.
- **유지보수 어려움** : 너무 많은 중첩 클래스를 사용하면 유지보수가 어려워질 수 있다. 코드를 변경할 때 각 클래스 간의 관계를 이해하고 변경 사항을 적용하기 어려울 수 있다.
- **오버헤드** : 내부 클래스는 클래스 로딩 및 인스턴스화에 추가 오버헤드를 초래할 수 있으므로 성능에 영향을 미칠 수 있다.

###### (참고 : https://everyshare.co.kr/java-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4-inner-class-4%EA%B0%80%EC%A7%80-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4/)
