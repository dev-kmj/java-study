# 📢 상속 & 오버라이딩
## 상속 
기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 

### 상속의 장점 
* 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다. 
* 코드를 공통적으로 관리할 수 있기 때문에 수정이 용이히다

```java
class Child extends Parent {
  //...
}
```
상속해주는 클래스를 `부모 클래스(super클래스)`라고 하고, 상속 받는 클래스를 `자식 클래스(sub클래스)`라고 한다.

<img src="https://github.com/dev-kmj/java-study/assets/74237301/acdd7f7a-8780-45ce-b507-bc94e05ebd0a" width="200" height="260"> 
<img src="https://github.com/dev-kmj/java-study/assets/74237301/c4f94b09-e076-4420-aeaf-c589c817fffe" width="280" height=180">



**자식 클래스는 부모 클래스의 모든 멤버를 상속**받기 때문에 Child클래스는 Parent클래스의 멤버들을 포함한다고 할 수 있다. 
만일 Parent클래스에 age라는 정수형 변수를 멤버변수로 추가하면, 자식 클래스는 부모의 멤버를 모두 상속받기 때문에, Child클래스에는 age라는 멤버변수가 자동으로 추가되는 효과를 얻는다.
```java
class Paent {
  int age;
}

class Child extends Parent {
  void play() {
    System.out.print("놀자");
  }
}
```
하지만 반대로 Child클래스에 새로운 멤버로 play()메서드를 추가하는 경우에는 부모클래스인 Parent클래스에 아무런 영향을 주지 않는다.
* 자식 클래스는 부모 클래스보다 항상 같거나 많은 멤버를 갖는다.  그래서 상속을 받는다는 것은 `클래스 확장(extend)`의 의미로 해석되어 `extends`라는 키워드가 사용된다.
* 자식 클래스의 인스턴스를 생성하면 부모 클래스의 멤버와 자식 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

### 클래스간의 포함관계
상속 이외에도 클래스 간에 `포함관계`를 맺어 재사용할 수 있다.
* 한 클래스의 멤버변수로 다른 클래스ㅇ 타입의 참조변수를 선언하는 것이다.

```java
class Circle {
  int x; //원점의 x좌표
  int y; //원점의 y좌표 
  int r;
}

class Point {
  int x;
  int y;
}

//Point클래스 재재사용 
class Circle {
  Point c = new Point();  //원점
  int r;
}
```

포함관계를 맺어주면, 클래스 작성과 관리가 쉽고 코드도 간결해서 이해하기 쉽다.

### 클래스간의 관계 결정하기 
클래스를 작성할 때 상속관계를 맺어 줄지 포함관계를 맺어줄지 결정할 때 `'~은 이다(is-a)'`와 `'~은 ~을 가지고 있다(has-a)'`를 넣어서 문장을 만들어 보면 관계가 더 명확해진다. 

위에서 포함관계로 작성했던 Circle 클래스를 상속 관계로 작성해보면 다음과 같다.
```java
class Circle extends Point {
  int r;
}
```
두 경우를 비교하기 위해 is-a와 has-a를 넣어 문장을 만들어 보자.
* 원(Circle)은 점(Point)이다. - Circle is a Point.
* 원(Circle)은 점(Point)을 가지고 있다. - Circle has a Point.

원은 원점(Point)과 반지름으로 구성되므로 두 번째 문장이 더 자연스럽다.
`is-a`가 성립하면 상속관계, `has-a`가 성립하면 포함관계를 맺어주는 것이 좋다. 따라서, Circle클래스와 Point클래스를 포함관계를 맺어주는 것이 더 적합하다. 

### 단일 상속 
c++에서는 여러 부모 클래스로부터 상속받는 '다중 상속'이 가능하지만 **자바에서는 단일 상속만을 허용하기 때문에 둘 이상의 클래스로부터 상속 받을 수 없다.**
* 다중 상속은 클래스 간의 관계가 복잡해지고, 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별이 어렵다는 단점이 있다.
* 자바에서는 다중 상속의 문제점 해결을 위해 장점을 포기하고 단일 상속만을 허용한다.
* 클래스 간의 관계가 보다 명확해지고 코드를 더 신뢰할 수 있게 만들어 준다.

### 모든 클래스의 부모인 Object
```java
class Tv {
  ...
}

//위의 코드를 컴파일하면 자동으로 Object클래스 상속받음
class Tv extends Object {
  ...
}
```
Object클래스는 모든 클래스의 부모이기 때문에 다른 클래스로부터 상속받는 경우에도 결국 마지막 `최상위 부모 클래스는 Object이다.`
* `toString()`, `equals()`와 같은 모든 인스턴스가 가져야 할 기본적인 11개의 메서드가 정의되어 있어 따로 정의하지 않고도 사용할 수 있다. 

## 오버라이딩 
"부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것"
상속받은 메서드를 그대로 사용하기도 하지만, 자식 클래스에 맞게 변경해야 하는 경우 오버라이딩을 사용한다.

```java
class Point {
  int x;
  int y;

  String getLocation() {
    return "x: " + x + ", y: " + y;
  }
}

class Point3D extends Point {
  int z;

  String getLocation() {
    retuirn "x: " + x + ", y: " + y + ", z: " + z;
  }
} 
```

한 점의 x,y 좌표를 문자열로 반환하는 메서드를 3차원 좌표계 표현을 위한 클래스에서 상속받는 경우, 자신에 맞게 z축의 좌표값도 포함하여 반환하도록 오버라이딩 할 수 있다.


### 오버라이딩 조건 
* 자식 클래스에서 오버라이딩하는 메서드는 부모 클래스의 메서드와 `이름`, `매개변수`, `반환타입`이 같아야 한다.
* 접근 제어자는 부모 클래스의 메서드보다 좁은 범위로 변경할 수 없다. (부모: protected -> 자식: protected/public)
* 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
* 인스턴스 메서드를 static메서드로 또는 그 반대로 변경할 수 없다.


### 오버로딩 vs 오버라이딩 

* `오버로딩`: 기존에 없는 **새로운 메서드를 정의** 하는 것 **(new)**
* `오버라이딩`: **상속받은 메서드의 내용을 변경**하는 것 **(change, modify)**


### super
`super`는 자식 클래스에서 **부모 클래스로부터 상속받은 멤버를 참조할 때 사용되는 참조변수**이다. 
* 상속받은 멤버와 자신의 멤버와 이름이 같은 경우 super를 붙여 구별한다.
* super 대신 this를 사용할 수 있다.
* 부모의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 superh와 this는 근본적으로 같다.
* static 메서드에서는 사용할 수 없고 **인스턴스 메서드에서만 사용할 수 있다.**


### super() 
`super()`는 조상 클래스의 생성자를 호출하는데 사용되는 생성자이다. 
* Object클래스를 제외한 **모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 부모의 생성자를 호출해야 한다.**
* 그렇지 않으면 컴파일러는 자동으로 `super()`를 추가한다.
