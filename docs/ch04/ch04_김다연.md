# 📌 상속 & 오버라이딩

## 상속의 이해
### 상속의 작동 방식
**한 클래스가 다른 클래스를 상속하는 것을 하위 클래스가 상위 클래스로부터 상속받는다**고 말함

자바에서는 **하위 클래스가 상위 클래스를 확장(extend)한다**고 얘기함

=> 하위 클래스가 상위클래스의 멤버를 물려받는다는 것을 의미


  예를 들어,

- **SuperHero** (상위 클래스)
  
  |인스턴스 변수|
  |-------------|
  |suit|
  |tights|
  |specialPower|

  |메서드|
  |-------|
  |useSpecialPower()|
  |putOnSuit()|

- **FriedEggMan** (하위 클래스)

  |FriedEggMan|
  |-------------|
  |             |
  |             |

- **PantherMan** (하위 클래스)

  |메서드|
  |-------|
  |useSpecialPower()|
  |putOnSuit()|

PantherMan이 SuperHero의 하위 클래스라면 PantherMan 클래스는 모든 '~맨' 시리즈애 공통적으로 있는 suit(옷), tights(쫄바지), specialPower(특수 능력),         useSpecialPower()(특수 능력을 발휘하는 메서드)와 같은 인스턴스 변수와 메서드를 자동으로 상속받음.

- FriedEggMan : 고유의 행동이 필요 없으므로 아무 메서드도 오버라이드 하지 않음
  (SuperHerop에 들어 있는 메서드와 인스턴스 변수만으로 충분하다면 굳이 오버라이드할 필요 없음)

- PantherMan : 옷과 특수 능력에 대한 별도의 요구사항이 있으므로 useSepcialPower()와 putOnSuit()를 모두 오버라이드함


### 상속 예제

    /* 일반적인 의사를 총칭하는 클래스 (상위 클래스) */
    
    public class Doctor {
    
      boolean worksAtHospital;   // 인스턴스 변수 한 개

      void treatPatient() {      // 메서드 한 개
        // 진료를 합니다.

      }
    }


    /* 가정의 (하위 클래스) */
    
    public class FamilyDoctor extends Doctor {
    
      boolean makesHouseCalls;    // 인스턴스 변수 하나 추가

      void giveAdvice() {         // 새 메서드 하나 추가
        // 집에서 필요한 조언을 합니다.
      }
    }


    /* 치과의사 (하위 클래스) */
    
    public class Surgeon extends Doctor { 
    
      void treatPatient() {       // 상속받은 treatPatient() 메서드 오버라이드
        // 외과 수술을 합니다.
      }

      void makeIncision() {       // 새 메서드 하나 추가
        //살을 벱니다. (헉!!)
      }
    }

## 상속 구조를 제대로 만들었는지 어떻게 알 수 있나요?
만약 'X는 Y다'가 성립한다면 이 두 클래스(X와 Y)는 모두 같은 상속 계층구조 안에 들어가도 됨.

- 상속에서 'A는 B다'관계는 한 방향으로만 작동함

  '삼각형은 도형이다'라는 명제는 참이므로, Triangle은 Shape 클래스를 확장할 수 있음. 하지만 그 반대(도형은 삼각형이다)는 참이 성립하지 않으므로 Shape 클래스가 Triangle 클래스를 확장하게 만들면 안 됨

  즉, 'X는 Y다'라고 하면 X는 Y가 할 수 있는 것(또는 그 이상)을 모두 할 수 있다는 뜻

## 상속을 활용해서 설계할 때 주의점
- 하위 클래스는 상위 클래스를 확장함
- 하위 클래스는 상위 클래스에 있는 모든 public으로 지정한 인스턴스 변수와 메서드를 상속함. 하지만 private으로 지정한 인스턴스 변수와 메서드는 상속하지 않음
- 상속된 메서드는 오버라이드할 수 있지만, 인스턴스 변수는 오버라이드할 수 없음
- 'A는 B다' 테스트를 활용해서 상속 계층이 올바른지 확인.
  
   X가 Y를 확장한 것이라면 'X는 Y다'라고 할 수 있어야 함
  
- 'A는 B다' 관계는 한 방향으로만 작동함.

  하마는 동물이지만, 모든 동물이 하마라고 할 수는 없는 것 처럼...
  
- 하위 클래스에서 메서드를 오버라이드했을 때, 하위 클래스의 인스턴스에 대해 그 메서드를 호출하면 오버라이드된 버전의 메서드가 호출됨
- B라는 클래스가 A라는 클래스를 확장하고 C는 B를 확장한다면 클래스 B는 클래스 A고, 클래스 C는 클래스 B이며, 클래스 C 또한 클래스 A임!

## 이런 상속 기능을 활용하면 어떤 장점이 있나요?
- 코드가 중복되는 것을 방지할 수 있음.

  공통적인 코드를 한 군데에 모아놓고 하위 클래스에서 상위 클래스로부터 상속을 받을 때 그 코드도 상속받게 함. 그 행동을 변경하고 싶으면 한 군데만 변경하면 나머지 모든 하위 클래스에서 변경된 기능을 활용할 수 있음

- 일련의 클래스를 위한 공통적인 프로토콜(protocol)을 정의함

  상위 클래스에서 메서드를 정의하면 그 메서드는 하위 클래스로 상속될 수 있음. 그 메서드의 정의는 다른 코드에 "내 타입에 속하는 모든 하위 클래스에서는 다음과 같은 메서드를 써서 이런 일을 할 수 있습니다."라고 알려 주는 일종의 프로토콜(규약)이라고 할 수 있다. 즉, 어떤 **'계약'** 을 맺는 것

하위 클래스는 전혀 건드릴 필요가 없다. 새로 컴파일한 상위 클래스를 기존의 상위 클래스가 있던 자리에 넣기만 하면 그 클래스를 확장한 하위 클래스에서는 자동으로 새로운 버전을 활용함

## 오버라이드 규칙
- 상위 클래스와 메서드를 오버라이드할 때는 계약을 이행해야 함.

  예를 들어서, '인자를 받지 않을 것이며 불리언 값을 리턴하겠음'과 같은 규칙을 그대로 따라야 함. 즉, 오버라이드하는 메서드의 인자와 리턴 타입은 외부에서 보기에 상위 클래스에서 오버라이드된 메서드와 완벽하게 일치해야 한다는 것.

- 메서드는 계약서와 같다

  다형성이 제대로 작동하려면 Toaster(토스터를 나타내는 클래스)에서 Appliance(가전제품을 의미하는 클래스)의 메서드를 오버라이드했을 때 그 메서드가 제대로 실행되어야 함


    Appliance appliance = new Toaster();


Toaster에 대한 Applance 레퍼런스가 있을 때, 컴파일러는 Appliance 레퍼런스에 대해 호출하는 메서드가 Appliance 클래스에 들어 있는지만 신경 씀. 하지만 실행할 때 JVM은 **레퍼런스 타입**이 아니라 힙에 들어 있는 실제 Toaster **객체**를 사용함

