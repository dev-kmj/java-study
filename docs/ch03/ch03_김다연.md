# 📌 오버로딩 & 생성자 & 변수의 초기화
## 메서드 오버로딩
`메서드 오버로딩(overloading)`은 이름은 같지만 인자 목록이 다른 메서드 두 개를 만드는 것. 오버로딩된 메서드는 메서드 이름만 같을 뿐 그냥 서로 다른 메서드임. 상속이나 다형성하고는 전혀 상관이 없다. **오버로딩**과 **오버라이딩**은 서로 다른 개념이다

오버로드하는 메서드에서는 상위 클래스에서 정의한 다형성 계약을 이행하지 않아도 되므로 메서드 오버로딩은 훨씬 더 융통성이 좋음

- ① 리턴 타입이 달라도 됨
     
  - 메서드를 오버로드할 때는 인자 목록만 다르면 리턴 타입을 마음대로 바꿔도 됨

- ② 리턴 타입만 바꿀 수는 없음
  
  - 리턴 타입만 다르게 하는 것은 올바른 오버로딩이 아님.
  - 리턴 타입이 상위 클래스에서 선언된 리턴 타입하고 같거나 그 하위 타입이 아닌 경우에는 컴파일러에서 오류 발생.
  - 메서드를 오버로딩할 때는 리턴타입하고는 무관하게 인자 목록을 반드시 변경해야 함
 
- ③ 접근 단계를 마음대로 바꿀 수 있음
  
  - 메서드를 오버로드해서 더 제한이 심한 메서드를 만들어도 됨
  - 새로운 메서드는 오버로드된 메서드의 계약 조건을 이행할 필요가 없으니 전혀 문제될 것이 없다!
 
### 메서드 오버로딩의 예시

    public class Overloads {
         String uniqueID;

         public int addNums(int a, int b) {
              return a + b;
          }

          public double addNums(double a, double b) {
               return a + b;
          }

          public void setUniqueID(String theID) {
               // 여러 검증 과정을 거치고 다음을 실행
               uniqueID = theID;
          }

          public void setUnique(int ssNumber) {
               String numString = "" + ssNumber;
               setUniqueID(numString);
          }
     }

## 기적과도 같은 객체 생성
### 객체의 삶의 비밀 밝혀 보기

객체 선언, 생성 및 대입의 3단계를 다시 훑어보면
- ① 레퍼런스 변수를 선언

      Duck myDuck

- ② 객체를 만듦

      new Duck();

- ③ 객체와 레퍼런스를 연결

      Duck myDuck = new Duck();

#### Duck() 이라는 이름을 가진 메서드를 호출하는 건가요?
#### 아닙니다. Duck '생성자'를 호출하는 것


