# 📌 오버로딩 & 생성자 & 변수의 초기화
## 메서드 오버로딩
`메서드 오버로딩(overloading)`은 이름은 같지만 인자 목록이 다른 메서드 두 개를 만드는 것. 오버로딩된 메서드는 메서드 이름만 같을 뿐 그냥 서로 다른 메서드임. 상속이나 다형성하고는 전혀 상관이 없다. **오버로딩**과 **오버라이딩**은 서로 다른 개념이다

오버로드하는 메서드에서는 상위 클래스에서 정의한 다형성 계약을 이행하지 않아도 되므로 메서드 오버로딩은 훨씬 더 융통성이 좋음

- ① 리턴 타입이 달라도 됨
     
  - 메서드를 오버로드할 때는 인자 목록만 다르면 리턴 타입을 마음대로 바꿔도 됨

- ② 리턴 타입만 바꿀 수는 없음
  
  - 리턴 타입만 다르게 하는 것은 올바른 오버로딩이 아님.
  - 리턴 타입이 상위 클래스에서 선언된 리턴 타입하고 같거나 그 하위 타입이 아닌 경우에는 컴파일러에서 오류 발생.
  - 메서드를 오버로딩할 때는 리턴타입하고는 무관하게 인자 목록을 반드시 변경해야 함
 
- ③ 접근 단계를 마음대로 바꿀 수 있음
  
  - 메서드를 오버로드해서 더 제한이 심한 메서드를 만들어도 됨
  - 새로운 메서드는 오버로드된 메서드의 계약 조건을 이행할 필요가 없으니 전혀 문제될 것이 없다!
 
### 메서드 오버로딩의 예시

    public class Overloads {
         String uniqueID;

         public int addNums(int a, int b) {
              return a + b;
          }

          public double addNums(double a, double b) {
               return a + b;
          }

          public void setUniqueID(String theID) {
               // 여러 검증 과정을 거치고 다음을 실행
               uniqueID = theID;
          }

          public void setUnique(int ssNumber) {
               String numString = "" + ssNumber;
               setUniqueID(numString);
          }
     }

## 기적과도 같은 객체 생성
### 객체의 삶의 비밀 밝혀 보기

객체 선언, 생성 및 대입의 3단계를 다시 훑어보면
- ① 레퍼런스 변수를 선언

      Duck myDuck

- ② 객체를 만듦

      new Duck();

- ③ 객체와 레퍼런스를 연결

      Duck myDuck = new Duck();

#### => Duck() 이라는 이름을 가진 메서드를 호출하는 것이 아닌, Duck '생성자'를 호출하는 것!

- 생성자를 호출할 때는 반드시 `new`라는 키워드를 쓰고 그 뒤에 `클래스` 명을 적어줘야 함
 - 생성자에는 객체를 생성할 때 실행되는 코드가 들어 있음. 즉, 어떤 클래스 타입에 대해 `new` 키워드를 사용했을 때 실행되는 코드가 들어 있음.
 - 우리가 만드는 **모든 클래스**에는 생성자가 있음

#### 생성자는 어디에 있나요? 누가 만드나요?

- 컴파일러에서 다음과 같이 기본 생성자를 만들어 줌

       public Duck() {
       }

- 생성자와 일반 메서드의 차이점

      public Duck() {
           // 생성자 코드가 들어갈 자리
       }

     - 생성자는 타입이 없음
     - 
       메서드라면 public과 Duck() 사이에 리턴 타입이 들어가야 함

     - 생성자명은 반드시 클래스명과 같아야 함
 
### Duck 객체 만들기

    public class Duck {
         public Duck() {     // 생성자 코드
              System.out.println("Quack");
          }
     }

생성자의 가장 중요한 특징은 객체가 레퍼런스에 대입되기 전에 실행된다는 점임.

    public class UseADuck {
         public static void main (String[] args) {
              Duck d = new Duck();      // Duck 생성자 호출
          }
     }

#### 생성자를 이용해서 Duck 객체의 상태를 초기화하는 방법

    public Duck() {
         size = 34;
     }

객체의 상태를 초기화 하는 방법, 즉 객체의 인스턴스 변수에 값을 대입하는 작업은 대부분 생성자에서 처리

    public class Duck {
          int size;

          public Duck(int duckSize) {      // Duck 생성자에 int 매개변수를 추가
               System.out.println("Quack");

               size = duckSize;            // 인자값을 이용해서 size 인스턴스 변숫값을 설정

               System.out.println("size is " + size);
          }
     }

초기화 코드를 집어넣기에 가장 좋은 장소는 생성자.

    public class UseADuck {
         public static void main (String[] args) {
              Duck d = new Duck(42);      // 생성자에 값을 전달
          }
     }


### 생성자 오버로딩을 이용하면 한 클래스에 두 개 이상의 생성자를 만들 수 있음
#### 이때 각 생성자의 인자 목록이 서로 다르지 않으면 컴파일이 되지 않음

    public class Mushroom {
         public Mushroom(int size) { }                    // 크기는 아는데 독버섯(magic mushroom)인지 아닌지 모를 경우
         public Mushroom() { }                            // 아무것도 모르는 경우
         public Mushroom(boolean isMagic) { }             // 독버섯인지, 아닌지는 알고 크기는 모르는 경우
         
         // 같은 인자가 쓰이지만 순서가 다르므로 괜찮음
         public Mushroom(boolean isMagic, int size) { }   // 독버섯인지 알고 있고 크기도 알고 있는 경우
         public Mushroom(int size, boolean isMagic) { }   // 독버섯인지 알고 있고 크기도 알고 있는 경우
     }

### 생성자에 대해 반드시 알아야 할 네 가지

- ① 생성자는 누군가가 어떤 클래스 타입에 대해 `new`를 쓸 때 실행되는 코드이다

      Duck d = new Duck();

- ② 생성자명은 반드시 클래스명과 같아야 하며 리턴 타입은 없음

      public Duck(int size) { }

- ③ 클래스를 만들 때 생성자를 만들지 않으면 컴파일러에서 기본 생성자를 자동으로 추가해 준다. 기본 생성자는 언제나 인자가 없는 생성자

      public Duck() { }

- ④ 인자 목록만 다르면 한 클래스에 생성자 여러 개를 만들 수도 있다. 한 클래스에 두 개 이상의 생성자가 있으면 **오버로드** 된 생성자가 있다고 말함

      public Duvk() { }
      public Duck(int size) { }
      pubilc Duck(String name) { }
      public Duck(String name, int size) { }

d
