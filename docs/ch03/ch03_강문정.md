# 📢 오버로딩 & 생성자 & 변수의 초기화 

## 1. 오버로딩 
"한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것" -> 메서드 하나의 이름으로 여러 개의 기능을 구현하는 것이다.
* 메서드 이름이 같아야 한다. 
* 매개변수의 개수나 타입이 달라야 한다.

위의 조건을 만족하지 않는 메서드는 중복 정의로 컴파일 시 에러가 발생한다. 
<br></br>
-> 가장 대표적인 예: `println()`<br>
PrintStream 클래스에 매개변수 타입별로 10개의 오버로딩된 `pritln()`메서드를 정의하고 있다. 메서드를 호출하면 매개변수로 넘겨주는 의 타입에 따라 오버로딩 된 메서드들 중 하나가 선택되어 실행된다. 

### 오버로딩의 장점 

메서드를 변수처럼 이름만으로 구별한다면, 한 클래스 내의 모든 메서들은 이름이 달라야 한다. 
```java
void println()
void printInBoolean(boolean x)
void printInChar(char x)
...
```
모두 근본적으로 같은 기능을 하는 메서드들인데 다른 이름을 가져야 한다면 이름을 짓기도 어렵고, 메서드를 사용하기도 불편하다. 오버로딩을 통해 `println()` 이라는 하나의 이름으로 정의되면 편리하게 사용 가능하고 오류의 가능성도 줄일 수 있다.

### 가변인자와 오버로딩 

가변인자는 `타입... 변수명`의 형식으로 선언한다. --> ex) PrintStream클래스의 `printf()`
* 가변인자 외에 매개변수가 더 있다면, **가변인자를 가장 마지막에 선언해야 한다.** 그렇지 않으면 컴파일 에러가 발생한다. 
```java
public PrintStream printf(String format, Object... args) { ... }
//컴파일 에러 발생
public PrintStream printf(Object... args, String format) { ... }
```
여러 문자열을 하나로 결합하여 반환하는 메서드를 작성할 때, 가변인자를 사용하면 메서드 하나로 간단히 대체할 수 있다.
```java
String concatenate(String s1, String s2) { ... }
String concatenate(String s1, String s2. String s3) { ... }
...
//가변인자 사용
String concatenate(String... str) { ... }
```

* 가변인자는 내부적으로 배열을 이용하기 때문에 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성다는 점에서 비효율이 생길 수 있다.
* 매개변수 타입을 배열로 하면, 반드시 인자를 지정해줘야 해서 인자를 생략할 수 없어 null이나 길이가 0인 배열을 인자로 지정해줘야 한다. 
* **가변인자를 선언한 메서드는 구분되지 않아 에러가 발생할 수 있기 때문에 오버로딩하지 않는 것이 좋다.**

## 2. 생성자 
### 생성자란? 
인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**로 인스턴스 변수의 초기화에 사용된다. 
* 생성자의 이름은 클래스 이름과 같아야 한다.
* 생성자는 리턴 값이 없다.
* 생성자는 오버로딩이 가능하므로 하나의 클래스에 여러 개 존재할 수 있다.
```java
class Card  {
	Card() {  //매개변수 없는 생성자 
		...
	}

	Card(String k, int num) { //매개변수가 있는 생성자 
		...
	}
	...
}
```
생성자가 인스턴스를 생성하는 것이 아니라 **연산자 new가 인스턴스를 생성한다.**
생성자는 단순히 인스턴스변수들의 초기화에 사용되는 것이다.

```java
Card c = new Card();
```
<인스턴스가 생성되는 과정> 
1. 연산자 new에 의해 heap memory에 Card클래스의 인스턴스 생성
2. 생성자 Card() 호출되어 수행
3. 연산자 new 의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 c에 저장 

### 기본 생성자
**모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.** 
* 컴파일러는 `클래스에 생성자가 하나도 없는 경우, 컴파일 시 소스파일에 `기본 생성자`를 추가하여 컴파일한다.`
* 이미 생성자가 정의되어 있는 경우에는 기본 생성자가 추가되지 않는다.

```java
class Data1 {
  int value;
}

class Data2 {
  int value;

  Data2(int x) {
    value = x;
  }
}
```
위처럼 생성자가 정의되지 않은 Data1은 컴파일러가 기본 생성자를 추가해준다. 하지만 이미 생성자 Data2(int x)가 정의되어 있는 Data2는 기본생성자가 추가되지 않는다.
```java
Data1 d1 = new Data1(); //잘 동작함 
Data2 d2 = new Data2(); //에러 발생 -> 이미 만들어진 Data2(int x)를 사용하거나 Data2()를 추가로 생성해줘야 함. 
```

### 매개변수가 있는 생성자 
생성자도 매개변수를 선언하여 호출 시 값을 넘겨받아 인스턴스의 초기화에 사용할 수 있다. 
```java
class Car {
  String color;
  String gearType;
  int door;

  Car() {} //생성자
  Car(String c, String g, int d) {
    color = c;
    gearType = g;
    door = d;
  }
}
```
`Car()`를 사용한다면 인스턴스를 생성하고 인스턴스 변수들을 일일이 초기화해줘야 한다. 하지만 **매개변수가 있는 생성자를 사용하면 인스턴스 생성과 동시에 원하는 값으로 초기화가 가능하다.**
```java
Car c = new Car("white", "auto", 4);
```
더 직관적이고 간결한 코드를 작성할 수 있다. 



### this(), this - 생성자에서 다른 생성자 호출하기 
두 조건을 만족시킨다면 생성자 간에도 같은 클래스 내의 멤버들을 호출하듯이 서로 호출이 가능하다. 
* 생성자의 이름으로 this를 사용한다.
* 다른 생성자를 호출할 때는 반드시 첫 줄에서만 가능하다.

생성자 내에서 초기화 작업 중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 초기화가 일어나기 때문에 진행중이던 초기화 작업이 무의미해진다. 

* 생성자간의 호출에는 생성자의 이름 대신 this를 사용해야 한다. 
```java
Car() {
  this("white", "auto", 4);
}
```
Car인스턴스를 생성한 경우에, 인스턴스 변수 color, gearType, door의 값을 각각 초기화되도록 한다. 



8 같은 클래스 내의 생성자들은 서로 관계가 깊은 경우가 많기 때문에 호출할 수 있도록 연결할 줄 수 있다. 
```java
Car(String color, String gearType, int door) {
  this.color = color;
  this.gearTyepe = gearType;
  this.door = door;
}
```
* `this` : 참조변수로 인스턴스 자기 자신을 가리킴<br> 

생성자의 매개변수로 선언된 변수의 이름이 인스턴스변수 color와 같기 때문에 **인스턴스 변수 앞에 `this`를 사용**해서 구별한다. (color = color의 경우 둘 다 지역변수)


### 생성자를 이용한 인스턴스의 복사 
두 인스턴스가 같은 상태를 갖는다는 것은 모든 인스턴스 변수(상태)가 동일한 값을 갖는다는 것이다. 


* Object클래스에 정의된 clone메서드를 이용하면 간단하게 인스턴스를 복사할 수 있다. (Java API 참고)

```java
Class Car {
  ...
  //인스턴스 복사를 위한 생성자 
  Car(Car c) {
    this(c.color, c.gearType, c.door);
  }

...
}
```
인스턴스 c2는 c1을 복사하여 생성된 것이므로 서로 같은 상태를 갖지만, 각자의 메모리공간에 존재하는 별도의 인스턴스이다. 따라서 c1의 값은 c2에 영향을 끼치지 않는다. 
```java
Car c1 = new Car();
Car c2 = new Car(c1);  
```

**인스턴스를 생성할 때 고려할 2가지 사항**
1. 어떤 클래스의 인스턴스를 생성할까?
2. 선택한 클래스의 어떤 생성자로 인스턴스를 생성할까?

## 3. 변수의 초기화 

"변수를 선언하고 처음으로 값을 저장하는 것"으로 가능하면 선언과 동시에 적절한 값으로 초기화하는 것이 좋다.
* 멤버변수는 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어진다.
* **지역변수는 사용하기 전에 반드시 초기화해야 한다.**

```java
class InitTest {
  //인스턴스변수
  int x;  
  int y = x;

  void method1() {
    int i;  //지역변수 
    int j = i; //지역변수를 초기화하지 않고 사용 -> 에러 
  }
}
```

### 명시적 초기화 
"변수를 선언과 동시에 초기화하는 것"
```java
class Car {
  int door = 4; //기본형 변수 초기화 
  Engine e = new Engine(); //참조형 변수 초기화
}
```
가장 간단한 방법이지만, `복잡한 초기화 작업이 필요할 때는 초기화 블럭이나 생성자를 사용`한다. 

### 멤버변수의 초기화 시기와 순서 

프로그램 실행 중 클래스에 대한 정보가 요구될 때, 클래스는 메모리에 로딩된다. - ex) 클래스 멤버 사용, 인스턴스 생성 
이미 해당 클래스가 메모리에 로딩되어 있다면, 또 다시 로딩하지 않으며 초기화도 수행되지 않는다. 

* **클래스 변수** : 클래스가 처음 로딩될 때(1회) 초기화 된다. (기본값 -> 명시적초기화 -> 클래스 초기화 블럭)
* **인스턴스 변수** : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다. (기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자)
