# 📢 쓰레드(Thread)

## 프로세스와 쓰레드

* `프로세스` : '실행중인 프로그램' ->  프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있음. (모든 프로세스는 최소한 하나 이상의 쓰레드가 존재)
* `쓰레드` : 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것

하나의 프로세스가 가질 수 있는 쓰레드의 개수는 제한되어 있지 않지만 쓰레드가 작업을 수행하는데 개별적인 메모리 공간을 필요로 하기 때문에 프로세스의 메모리 한계에 따라 생성가능한 쓰레드 수가 결정된다.

### 멀티쓰레딩의 장점 
* CPU의 사용률을 향상시킨다.
* 자원을 보다 효율적으로 사용할 수 있다.
* 사용자에 대한 응답성이 향상된다.
* 작업이 분리되어 코드가 간결해진다.

## 쓰레드의 구현과 실행 

### 구현
* Thread클래스를 상속
```java
class MyThread extends Thread {
  public void run() { }
}
```
* Runnable인터페이스를 구현
```java
class MyThread implements Runnable {
  public void run() { }
}
```

Runnable인터페이스를 구현한 경우, Runnable인터페이스를 구현한 클래스의 인스턴스를 생성한 다음, 이 인스턴스를 Thread클래스의 생성자의 매개변수로 제공해야 한다. 

```java
public class Thread {
  private Runnable r;

  public Thread(Runnable r) {
    this.r = r;
  }

  public void run() {
    if(r != null) r.run();  // Runnable인터페이스를 구현한 인스턴스의 run()을 호출 
  }
  ...
}
```

인스턴스변수로 Runnable타입의 변수 r을 선언하고 생성자를 통해서 Runnable인터페이스를 구현한 인스턴스를 참조하도록 한 후 run()을 호출하면 오버라이딩을 하지 않아도 된다.


### 쓰레드의 실행 - start()
* 쓰레드를 생성했다고 자동으로 실행되는 것이 아니라 `start()`를 호출해야 한다. 
```java
t1.start();  //쓰레드 t1을 실행시킨다. 
t2.start();  //쓰레드 t2를 실행시킨다.
```
* `start()`를 호출한다고 바로 실행되는 것이 아니라 일단 실행대기 상태에 있다가 자신의 차례가 되면 실행된다. 실행대기중인 쓰레드가 하나도 없으면 바로 실행상태가 된다. 
* 한 번 실행이 종료된 쓰레드는 다시 실행될 수 없다. (**하나의 쓰레드에 대해 start()는 한 번만 호출 가능**)
* 쓰레드의 작업을 한 번 더 수행해야 한다면 새루운 쓰레드를 생성한 다음에 호출해야 한다. 


## start()와 run()

* `run()` : main메서드에서 run()을 호출하는 것은 단순히 클래스에 선언된 메서드를 호출하는 것이다.
* `start()` : 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음에 run()을 호출해서, 생성된 호출스택에 run()이 첫 번째로 올라가게 한다. '

main쓰레드는 main메서드의 작업을 수행한다. 프로그램을 실행하면 기본적으로 하나의 쓰레드(일꾼)을 생성하고, 그 쓰레드가 main메서드를 호출해서 작업을 수행하도록 하는 것이다. 

**실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.**


## 싱글쓰레드와 멀티쓰레드
* 쓰레드간의 `작업전환(context switching)`에 걸리는 시간 때문에 오히려 두 개의 쓰레드로 작업한 시간이 싱글쓰레드로 작업한 시간보다 더 걸린다. 그래서 싱글 코어에서 단순히 CPU만을 사용하는 계산작업이라면 싱글쓰레드로 프로그래밍하는 것이 더 효율적이다. 
<img src="https://github.com/dev-kmj/java-study/assets/74237301/1e4a8a5f-41f6-4d06-ac60-b584df157061" width=850 height=350>


싱글 코어인 경우에는 멀티쓰레드라도 하나의 코어가 번갈아 가면서 작업을 수행하는 것이므로 두 작업이 절대 겹치지 않는다. 그러나, 멀티코어에서는 멀쓰레드로 두 작업을 수행하면, 동시에 두 쓰레드가 실행될 수 있으므로 A와 B가 겹치는 부분이 발생한다.
그래서 화면(console)이라는 자원을 두고 두 쓰레드가 경쟁하게 된다. JVM의 쓰레드 스케줄러에 의해서 어떤 쓰레드가 얼마나 실행될 것인지 결정되는 것처럼 프로세스도 스케줄러에 의해 실행순서와 시간이 결정된다. 
프로세스와 쓰레드에게 할당되는 시간은 일정하지 않기 떄문에 `쓰레드는 불확실성을 가지고 있다`는 점을 염두해 두어야 한다. 


만일 사용자로부터 입력받는 작업과 화면에 출력하는 작업을 하나의 쓰레드로 처리한다면 사용자가 입력을 마칠 때까지 아무 일도 하지 못하고 기다리기만 해야 한다.<br>
그러나 두 개의 쓰레드로 처리한다면 사용자의 입력을 기다리는 동안 다른 쓰레드가 작업을 처리할 수 있기 때문에 보다 효율적이 CPU 사용이 가능하다. 


## 쓰레드의 실행제어 
* **sleep(long mills) - 일정 시간동안 쓰레드를 멈추게 한다**
  ```java
  //static void sleep(long mills,. int nanos)
  void delay(long mills) {
    try {
      Thread.sleep(mills);
    } catch(InterruptedException e) {}
  }
  ```
  일시정지 상태가 된 쓰레드는 지정된 시간이 다 되거나 interrupt()가 호출되면, 실행대기 상태가 된다. `sleep()`을 호출할 때는 항상 `try-catch문으로 예외를 처리`해줘야 한다.

* **interrupt() / interuupted() - 쓰레드의 작업을 취소한다**
  
  진행중인 쓰레드의 작업이 끝나기 전에 취소해야 하는 경우에 사용한다. (ex - 큰 파일을 다운로드 받을 때 시간이 너무 오래걸려 중간에 다운로드를 포기하고 취소하는 경우..)

* **suspend(), resume(), stop()**
  suspend()는 sleep()처럼 쓰레드를 멈추게 한다 . `suspend()`에 의해 정지된 쓰레드는 `resume()`을 호출해야 다시 실행대기 상태가 된다. `stop()`은 호출되는 즉시 쓰레드가 종료된다.

    
## 쓰레드의 동기화

멀티쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 줘서 의도와 다른 결과를 얻을 수 있다. <br>
이러한 일을 방지하기 위해 **한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것**이 필요해 도입된 개념이 `임계 영역(cirtical section)`과 `잠금(lock)`이다. 

### synchrnoized를 이용한 동기화 
**1. 메서드 전체를 임계 영역으로 지정**
```java
public synchronized void calcSum() {
  //...
}
```
메서드 전체가 임계영역으로 설정된다. 쓰레드는 synchronized가 호출된 시점부터 해당 메서드가 포함된 객체의 lock을 얻어 작업을 수행하다가 메서드가 종료되면 lock을 반환한다. 

**2. 특정한 영역을 임계 영역으로 지정**
```java
synchronized(객체의 참조변수) {
  //...
}
```
synchronized블럭의 영역 안으로 들어가면서 쓰레드는 지정된 객체의 lock을 얻게 되고, 블럭을 벗어나면 lock을 반납한다.

* synchronized블럭으로 동기화를 하면 자동적으로 lock이 잠기고 풀리기 때문에 편리하다. 그러나 같은 메서드 내에서만 lock을 걸 수 있다는 제약이 불편한 경우에는 lock클래스를 사용한다. 

### wait()과 notify()

만일 계좌에 출금할 돈이 부족해서 한 쓰레드가 락을 보유한 채로 돈이 입금될 때까지 오랜 시간을 보낸다면, 다른 쓰레드들은 모두 해당 객체의 락을 기다리느라 작업을 제대로 할 수 없게된다.
이러한 상황을 개선하기 위해 `wait()`와 `notify()`가 있다. <br>

1) 동기화된 임계영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, `wait()`를 호출하여 쓰레드가 락을 반납하고 기다리게 한다. <br>
2) 그러면, 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있게 된다 
3) 나중에 작업을 다시 수행할 수 있는 상황에 `notify()`를 호출해서, 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.

 


